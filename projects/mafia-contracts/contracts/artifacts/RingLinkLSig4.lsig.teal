#pragma version 10
//#pragma mode logicsig
intcblock 0 1 32 5 6 7 96
bytecblock 0x

// This TEAL was generated by TEALScript v0.106.2
// https://github.com/algorandfoundation/TEALScript

// The address of this logic signature is ZEM7TYWNURHFFZYIC2U5TYJINBLUD6WQCXSF7ZIMTDKMDF2Z6WBZG2PQGQ

b *route_logic

// logic(address,byte[],uint64,byte[],byte[],byte[])void
*route_logic:
	// challenges: byte[]
	intc 3 // 5
	args
	extract 2 0

	// sig: byte[]
	pushint 4
	args
	extract 2 0

	// keyImage: byte[]
	pushint 3
	args
	extract 2 0

	// pkIndex: uint64
	pushint 2
	args
	btoi

	// pkAll: byte[]
	intc 1 // 1
	args
	extract 2 0

	// msg: address
	intc 0 // 0
	args
	dup
	len
	intc 2 // 32
	==

	// argument 5 (msg) for logic must be a address
	assert

	// execute logic(address,byte[],uint64,byte[],byte[],byte[])void
	callsub logic
	intc 1 // 1
	return

// logic(msg: Address, pkAll: bytes, pkIndex: uint64, keyImage: bytes, sig: bytes, challenges: bytes): void
//
// logic: challenge
// Produce the challenge, i.e. an individual link in the ring sig verification.
// We mod by order of fr https://github.com/Consensys/gnark-crypto/blob/master/ecc/bn254/fr/element.go#L42
// c_{i+1} = Hs(m || r_{i} * G + c_{i} * K_{i} || r_{i}*Hp(K_{i}) + c_{i} * I) mod |fr|
// @param msg - The message to be signed
// @param pkAll - All public keys in the ring, in 1 large byte array, equivalent to the box in the application
// @param pkIndex - The specific public key in the ring (indexed from the array of public keys)
// @param keyImage - The key image of the signer, required for linkabiltiy to prevent double spending
// @param sig - The ring sig nonces, in 1 large byte array. The core of the ring sig itself.
// @param challenges - The challenges, in 1 large byte array. Intermediate values. We check if what's provided into the contract is the same as what is calculated.
logic:
	proto 6 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dupn 8

	// contracts/RingLinkLSig4.algo.ts:26
	// nonce = extract3(sig, iter * RING_SIG_NONCE_LENGTH, (iter + 1) * RING_SIG_NONCE_LENGTH)
	frame_dig -5 // sig: bytes
	extract 128 160
	frame_bury 0 // nonce: byte[]

	// contracts/RingLinkLSig4.algo.ts:27
	// cPrev = extract3(challenges, iter * RING_SIG_CHALL_LENGTH, (iter + 1) * RING_SIG_CHALL_LENGTH)
	frame_dig -6 // challenges: bytes
	extract 128 160
	frame_bury 1 // cPrev: byte[]

	// contracts/RingLinkLSig4.algo.ts:28
	// pk = extract3(pkAll, pkIndex * BLS12381G1_LENGTH, (pkIndex + 1) * BLS12381G1_LENGTH)
	frame_dig -2 // pkAll: bytes
	frame_dig -3 // pkIndex: uint64
	intc 6 // 96
	*
	frame_dig -3 // pkIndex: uint64
	intc 1 // 1
	+
	intc 6 // 96
	*
	extract3
	frame_bury 2 // pk: byte[]

	// contracts/RingLinkLSig4.algo.ts:34
	// left = ecAdd(
	//       'BLS12_381g1',
	//       ecScalarMul('BLS12_381g1', hex(BLS12381G1_BASEPOINT_BYTES), nonce),
	//       ecScalarMul('BLS12_381g1', cPrev, pk)
	//     )
	pushbytes 0x00000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000002
	frame_dig 0 // nonce: byte[]
	ec_scalar_mul BLS12_381g1
	frame_dig 1 // cPrev: byte[]
	frame_dig 2 // pk: byte[]
	ec_scalar_mul BLS12_381g1
	ec_add BLS12_381g1
	frame_bury 3 // left: byte[]

	// contracts/RingLinkLSig4.algo.ts:42
	// hash = keccak256(pk)
	frame_dig 2 // pk: byte[]
	keccak256
	frame_bury 4 // hash: byte[32]

	// contracts/RingLinkLSig4.algo.ts:43
	// fpElement = btobigint(hash) % btobigint(hex(BLS12381_FIELD_MODULUS_HEX))
	frame_dig 4 // hash: byte[32]
	pushbytes 0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab
	b%
	frame_bury 5 // fpElement: bigint

	// contracts/RingLinkLSig4.algo.ts:46
	// hp2p = ecMapTo('BLS12_381g1', rawBytes(fpElement))
	frame_dig 5 // fpElement: bigint
	ec_map_to BLS12_381g1
	frame_bury 6 // hp2p: byte[]

	// contracts/RingLinkLSig4.algo.ts:52
	// right = ecAdd(
	//       'BLS12_381g1',
	//       ecScalarMul('BLS12_381g1', nonce, hp2p),
	//       ecScalarMul('BLS12_381g1', cPrev, keyImage)
	//     )
	frame_dig 0 // nonce: byte[]
	frame_dig 6 // hp2p: byte[]
	ec_scalar_mul BLS12_381g1
	frame_dig 1 // cPrev: byte[]
	frame_dig -4 // keyImage: bytes
	ec_scalar_mul BLS12_381g1
	ec_add BLS12_381g1
	frame_bury 7 // right: byte[]

	// contracts/RingLinkLSig4.algo.ts:62
	// h = rawBytes(
	//       btobigint(keccak256(concat(concat(msg, left), right))) % btobigint(hex(BLS12381_CURVE_ORDER_HEX))
	//     )
	frame_dig -1 // msg: Address
	frame_dig 3 // left: byte[]
	concat
	frame_dig 7 // right: byte[]
	concat
	keccak256
	pushbytes 0x73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001
	b%
	frame_bury 8 // h: byte[]

	// contracts/RingLinkLSig4.algo.ts:66
	// assert(
	//       h === extract3(challenges, ((iter + 1) % 7) * RING_SIG_CHALL_LENGTH, ((iter + 2) % 7) * RING_SIG_CHALL_LENGTH)
	//     )
	frame_dig 8 // h: byte[]
	frame_dig -6 // challenges: bytes
	intc 3 // 5
	intc 5 // 7
	%
	intc 2 // 32
	*
	intc 4 // 6
	intc 5 // 7
	%
	intc 2 // 32
	*
	extract3
	==
	assert

	// contracts/RingLinkLSig4.algo.ts:70
	// verifyAppCallTxn(this.txnGroup[0], {
	//       applicationArgs: {
	//         0: rawBytes(msg),
	//         1: rawBytes(pkAll),
	//         2: rawBytes(keyImage),
	//         3: rawBytes(sig),
	//         4: rawBytes(challenges),
	//       },
	//     })
	// verify appl
	intc 0 // 0
	gtxns TypeEnum
	intc 4 //  appl
	==

	// transaction verification failed: {"txn":"this.txnGroup[0]","field":"typeEnum","expected":"appl"}
	assert

	// verify applicationArgs
	// verify applicationArgs 0
	intc 0 // 0
	gtxns ApplicationArgs 0
	frame_dig -1 // msg: Address
	==

	// transaction verification failed: {"txn":"this.txnGroup[0]","field":"applicationArgs","index":"0","expected":"rawBytes(msg)"}
	assert

	// verify applicationArgs 1
	intc 0 // 0
	gtxns ApplicationArgs 1
	frame_dig -2 // pkAll: bytes
	dup
	len
	itob
	extract 6 2
	swap
	concat
	==

	// transaction verification failed: {"txn":"this.txnGroup[0]","field":"applicationArgs","index":"1","expected":"rawBytes(pkAll)"}
	assert

	// verify applicationArgs 2
	intc 0 // 0
	gtxns ApplicationArgs 2
	frame_dig -4 // keyImage: bytes
	dup
	len
	itob
	extract 6 2
	swap
	concat
	==

	// transaction verification failed: {"txn":"this.txnGroup[0]","field":"applicationArgs","index":"2","expected":"rawBytes(keyImage)"}
	assert

	// verify applicationArgs 3
	intc 0 // 0
	gtxns ApplicationArgs 3
	frame_dig -5 // sig: bytes
	dup
	len
	itob
	extract 6 2
	swap
	concat
	==

	// transaction verification failed: {"txn":"this.txnGroup[0]","field":"applicationArgs","index":"3","expected":"rawBytes(sig)"}
	assert

	// verify applicationArgs 4
	intc 0 // 0
	gtxns ApplicationArgs 4
	frame_dig -6 // challenges: bytes
	dup
	len
	itob
	extract 6 2
	swap
	concat
	==

	// transaction verification failed: {"txn":"this.txnGroup[0]","field":"applicationArgs","index":"4","expected":"rawBytes(challenges)"}
	assert
	retsub