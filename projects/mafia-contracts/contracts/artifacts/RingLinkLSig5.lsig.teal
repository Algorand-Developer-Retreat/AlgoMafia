#pragma version 10
//#pragma mode logicsig
intcblock 5 1
bytecblock 0x

// This TEAL was generated by TEALScript v0.106.2
// https://github.com/algorandfoundation/TEALScript

// The address of this logic signature is LTKD7WQPXM344TU2XAUHINHUMXEBCBPLRDMBZLQ27KUWFMUA52BFRCEUEE

b *route_logic

// logic(byte[],byte[],byte[],byte[],byte[],byte[])void
*route_logic:
	// cExpected: byte[]
	intc 0 // 5
	args
	extract 2 0

	// cPrev: byte[]
	pushint 4
	args
	extract 2 0

	// nonce: byte[]
	pushint 3
	args
	extract 2 0

	// keyImage: byte[]
	pushint 2
	args
	extract 2 0

	// pk: byte[]
	intc 1 // 1
	args
	extract 2 0

	// msg: byte[]
	pushint 0
	args
	extract 2 0

	// execute logic(byte[],byte[],byte[],byte[],byte[],byte[])void
	callsub logic
	intc 1 // 1
	return

// logic(msg: bytes, pk: bytes, keyImage: bytes, nonce: bytes, cPrev: bytes, cExpected: bytes): void
//
// logic: challenge
// Produce the challenge, i.e. an individual link in the ring sig verification.
// We mod by order of fr https://github.com/Consensys/gnark-crypto/blob/master/ecc/bn254/fr/element.go#L42
// c_{i+1} = Hs(m || r_{i} * G + c_{i} * K_{i} || r_{i}*Hp(K_{i}) + c_{i} * I) mod |fr|
// @param msg - The message to be signed
// @param pk - The public key relevant to this link.
// @param keyImage - The key image of the signer, required for linkabiltiy to prevent double spending
// @param nonce - The ring sig nonces, in 1 large byte array. The core of the ring sig itself.
// @param cPrev - The input "challenge", or previous challenge in the ring sig verification flow.
// @param cExpected - The expected challenge, to be compared against the calculated challenge.
logic:
	proto 6 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dupn 5

	// contracts/RingLinkLSig5.algo.ts:23
	// left = ecAdd(
	//       'BLS12_381g1',
	//       ecScalarMul('BLS12_381g1', hex(BLS12381G1_BASEPOINT_BYTES), nonce),
	//       ecScalarMul('BLS12_381g1', pk, cPrev)
	//     )
	pushbytes 0x17f1d3a73197d7942695638c4fa9ac0fc3688c4f9774b905a14e3a3f171bac586c55e83ff97a1aeffb3af00adb22c6bb08b3f481e3aaa0f1a09e30ed741d8ae4fcf5e095d5d00af600db18cb2c04b3edd03cc744a2888ae40caa232946c5e7e1
	frame_dig -4 // nonce: bytes
	ec_scalar_mul BLS12_381g1
	frame_dig -2 // pk: bytes
	frame_dig -5 // cPrev: bytes
	ec_scalar_mul BLS12_381g1
	ec_add BLS12_381g1
	frame_bury 0 // left: byte[]

	// contracts/RingLinkLSig5.algo.ts:31
	// hash = keccak256(pk)
	frame_dig -2 // pk: bytes
	keccak256
	frame_bury 1 // hash: byte[32]

	// contracts/RingLinkLSig5.algo.ts:32
	// fpElement = btobigint(hash) % btobigint(hex(BLS12381_FIELD_MODULUS_HEX))
	frame_dig 1 // hash: byte[32]
	pushbytes 0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab
	b%
	frame_bury 2 // fpElement: bigint

	// contracts/RingLinkLSig5.algo.ts:35
	// hp2p = ecMapTo('BLS12_381g1', rawBytes(fpElement))
	frame_dig 2 // fpElement: bigint
	ec_map_to BLS12_381g1
	frame_bury 3 // hp2p: byte[]

	// contracts/RingLinkLSig5.algo.ts:41
	// right = ecAdd(
	//       'BLS12_381g1',
	//       ecScalarMul('BLS12_381g1', hp2p, nonce),
	//       ecScalarMul('BLS12_381g1', keyImage, cPrev)
	//     )
	frame_dig 3 // hp2p: byte[]
	frame_dig -4 // nonce: bytes
	ec_scalar_mul BLS12_381g1
	frame_dig -3 // keyImage: bytes
	frame_dig -5 // cPrev: bytes
	ec_scalar_mul BLS12_381g1
	ec_add BLS12_381g1
	frame_bury 4 // right: byte[]

	// contracts/RingLinkLSig5.algo.ts:51
	// h = rawBytes(
	//       btobigint(keccak256(concat(concat(msg, left), right))) % btobigint(hex(BLS12381_CURVE_ORDER_HEX))
	//     )
	frame_dig -1 // msg: bytes
	frame_dig 0 // left: byte[]
	concat
	frame_dig 4 // right: byte[]
	concat
	keccak256
	pushbytes 0x73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001
	b%
	frame_bury 5 // h: byte[]

	// contracts/RingLinkLSig5.algo.ts:55
	// assert(h === cExpected)
	frame_dig 5 // h: byte[]
	frame_dig -6 // cExpected: bytes
	==
	assert
	intc 0 // 5
	dup
	==
	retsub